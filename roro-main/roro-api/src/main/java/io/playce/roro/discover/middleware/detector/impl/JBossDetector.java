package io.playce.roro.discover.middleware.detector.impl;/* * Copyright 2022 The Playce-RoRo Project. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * Revision History * Author            Date                Description * ---------------  ----------------    ------------ * Jhpark       8월 02, 2022            First Draft. */import io.playce.roro.common.code.Domain1013;import io.playce.roro.common.code.Domain1102;import io.playce.roro.common.dto.common.InventoryProcessConnectionInfo;import io.playce.roro.common.util.support.TargetHost;import io.playce.roro.discover.middleware.detector.AbstractDetector;import io.playce.roro.discover.middleware.dto.DetectResultInfo;import io.playce.roro.discover.middleware.scenario.ExtractScenario;import io.playce.roro.discover.middleware.scenario.jboss.JbossDomainPathScenario;import io.playce.roro.discover.middleware.scenario.jboss.JbossEnginePathScenario;import io.playce.roro.discover.middleware.scenario.jboss.JbossNodeNameScenario;import io.playce.roro.mw.asmt.component.CommandConfig;import io.playce.roro.mw.asmt.util.GetInfoStrategy;import io.playce.roro.svr.asmt.dto.common.processes.Process;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;/** * <pre> * * </pre> * * @author jhpark * @version 3.0 */@Slf4jpublic class JBossDetector extends AbstractDetector {    public JBossDetector(Process process) {        super(process);    }    private final String VENDOR_NAME = "Red Hat";    private final String STANDALONE_MODE = "org.jboss.as.standalone";    private final String DOMAIN_MODE = "org.jboss.as.host-controller";    @Override    public DetectResultInfo generateMiddleware(TargetHost targetHost, InventoryProcessConnectionInfo connectionInfo, CommandConfig commandConfig, GetInfoStrategy strategy) throws InterruptedException {        String processName = generateNodeNameScenario(targetHost).execute(process, commandConfig, strategy);        String enginePath = generateEnginePathScenario(targetHost).execute(process, commandConfig, strategy);        String domainPath = generateDomainPathScenario(targetHost).execute(process, commandConfig, strategy);        /**         * engineType         * JBOSS Mode : Standalone , domain 미들웨어가 2개 가능함.         * [domain 모드는 process controller 프로세스 와  host controller 프로세스로 나뉨 / process controller 프로세스는   Djboss.home.dir 엔진 경로가 없음]         */        //String engineMode = getEngineModeName(process);        if(StringUtils.isEmpty(enginePath)) {            log.debug("The engine path could not be found. {}", process);            return null;        }        if(StringUtils.isEmpty(domainPath)) {            log.debug("The domain path could not be found. {}", process);            return null;        }        return DetectResultInfo.builder()                .vendor(VENDOR_NAME)                .mwDetailType(Domain1013.JBOSS)                .mwType(Domain1102.WAS)                .pid(process.getPid())                .runUser(process.getUser())                .processName(processName)                .enginePath(enginePath)                .domainPath(domainPath)                .javaVersion(getJavaVersion(process.getCmd(),targetHost, commandConfig, strategy))                .build();    }    private ExtractScenario generateDomainPathScenario(TargetHost targetHost) {        ExtractScenario scenario = new JbossDomainPathScenario();        ExtractScenario.setChain(targetHost, scenario);        return  scenario;    }    private ExtractScenario generateNodeNameScenario(TargetHost targetHost){        ExtractScenario scenario = new JbossNodeNameScenario();        scenario.setTargetHost(targetHost);        return scenario;    }    private ExtractScenario generateEnginePathScenario(TargetHost targetHost) {        ExtractScenario scenario = new JbossEnginePathScenario();        scenario.setTargetHost(targetHost);        return scenario;    }    private String getEngineModeName(Process process){        if(process.getCmd().stream().anyMatch(cmd -> cmd.contains(STANDALONE_MODE))){            return "Standalone";        }        return "Domain";    }}